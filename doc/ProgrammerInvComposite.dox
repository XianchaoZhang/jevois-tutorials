/*! \page ProgrammerInvComposite 创建复合输出视频帧

JeVois 附带的许多机器视觉模块都具有出色的复合显示，可以并排显示机器视觉结果与 JeVois 捕获的原始视频。

本教程将向您展示如何在 Python + OpenCV 中实现这一点。我们将使用 JeVois Inventor，因为它使 JeVois 的 Python 模块编程变得更加容易。

您展示的计划 
----------------

首先考虑一下你的布局。为什么你需要几个展示板以及你希望它们传达什么信息？

对于本教程，我们假设我们想要在左侧显示 JeVois 捕获的原始 320x240 视频，在右侧显示一些 320x240 的机器视觉结果，以及在下方显示 50 像素高的消息区域。

创建您的模块 
------------------

- 从 JeVois Inventor 的下拉菜单中选择 <b>New Python Module...</b> （或按 `CTRL-N`）。

- 填写如下所示的详细信息：

\jvimg{invcompo1.png, 40%}

几点说明：

- 根据上面建议的布局，对于 320x240 的输入视频，我们的输出视频应为 640 像素宽（对于两个并排的视频图像），290 像素高（输入视频的 240 像素加上我们的消息区域的 50 像素）。
- 如果您决定稍后向输出图像添加更多面板，可以通过编辑 \b videomappings.cfg 进行更改。

允许 JeVois 重新启动，从 <b>Vision Module</b> 下拉菜单中选择新模块，然后切换到 <b>Code</b> 选项卡。

编写代码 
--------------

让我们从简单的开始，仅创建一个机器视觉处理结果，它只是输入的模糊版本。

我们创建复合显示如下：

\code{.py}
import libjevois as jevois
import cv2
import numpy as np
class CompoTest:
    def process(self, inframe, outframe):
      # Get the next camera frame as BGR:
      img = inframe.getCvBGR()
      
      # Blur it with a 11x11 kernel; this is our result image:
      res = cv2.blur(img, (11, 11))
      
      # Horizontally concatenate input at left + result at right:
      sidebyside = np.hstack((img, res))
      
      # Create dark-gray (value 80) image for the bottom panel, 50 pixels tall:
      msgbox = np.zeros((50, sidebyside.shape[1], 3), dtype = np.uint8) + 80
      
      # Write some text in the bottom panel:
      cv2.putText(msgbox, 'Hello JeVois!', (10, 40), cv2.FONT_HERSHEY_SIMPLEX,
          1, (255,255,255), 2, cv2.LINE_AA)
      
      # Stack bottom panel below side by side images:
      out = np.vstack((sidebyside, msgbox))
      
      # Send off the result:
      outframe.sendCv(out)
\endcode


下面是：

\jvimg{invcompo2.png, 60%}

要记住以下几点：

- OpenCV 和 numpy 对图像使用线性代数矩阵约定，其中第一个索引是行 (y)，第二个索引是列 (x)。例如，查看我们在 `np.zeros()` 调用中使用的大小或 `np.shape` 的索引。

- 但是它们对坐标之类的东西使用图像处理约定，其中第一个索引是 x，第二个索引是 y。例如，请参阅 `cv2.putText()` 中文本的坐标。

- 如果您以不假设特定输入视频大小的方式编写代码，那么您将能够将其与不同的相机传感器分辨率一起使用。例如，在上面，我们使用 `sidebyside.shape[1]` 而不是 `640` 作为并排图像的宽度。


混合像素类型 
------------------

有时，得到的结果与输入的像素格式不同。在这种情况下，只需在组装最终的复合输出之前将其转换回 BGR。

例如，在这里，我们使用 Canny 边缘检测器而不是颜色模糊将结果更改为灰度。然后，我们使用 `cv2.cvtColor()` 将灰度边缘图转换回 BGR，然后创建并排图像：

\code{.py}
import libjevois as jevois
import cv2
import numpy as np
class CompoTest:
    def process(self, inframe, outframe):
      # Get the next camera frame as BGR:
      img = inframe.getCvBGR()
      
      # Compute edges in the image; this is our grayscale result:
      res = cv2.Canny(img, 100, 200)                                  # new code
      
      # Convert the grayscale results to BGR:
      resbgr = cv2.cvtColor(res, cv2.COLOR_GRAY2BGR)                  # new code
      
      # Horizontally concatenate input at left + result at right:
      sidebyside = np.hstack((img, resbgr))                           # modified code
      
      # Create dark-gray (value 80) image for the bottom panel, 50 pixels tall:
      msgbox = np.zeros((50, sidebyside.shape[1], 3), dtype = np.uint8) + 80
      
      # Write some text in the bottom panel:
      cv2.putText(msgbox, 'Hello JeVois!', (10, 40), cv2.FONT_HERSHEY_SIMPLEX,
          1, (255,255,255), 2, cv2.LINE_AA)
      
      # Stack bottom panel below side by side images:
      out = np.vstack((sidebyside, msgbox))
      
      # Send off the result:
      outframe.sendCv(out)
\endcode



\jvimg{invcompo3.png, 60%}

深入了解 
------------

本教程中解释的方法效果很好而且直观，但是复制和连接 BGR 图像会产生大量 CPU 成本。

更有效的方法是将输入和结果图像直接粘贴到将通过 USB 发送的输出图像缓冲区中。\ref ModulePythonTutorial 中的 "使用 JeVois 原始图像进行更细粒度的控制" 部分简要介绍了这种更高级但更高效的方法。

*/

