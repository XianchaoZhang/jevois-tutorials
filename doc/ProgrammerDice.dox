/*! \page ProgrammerDice C++ 中的 JeVois 骰子计数模块

这里我们开发了一个简单的 C++ OpenCV 视觉模块，用于计算 JeVois 收到的骰子上的总点数。此应用场景由 JeVois 用户 mapembert 在 [JeVois Tech Zone](http://jevois.org/qa) 的这篇文章中提出：

http://jevois.org/qa/index.php?qa=328

在本教程中，您将学习：

- 如何从头开始为 JeVois 创建新的 C++ 机器视觉模块
- 如何用 Python 实现骰子计数算法
- 如何将新模块安装到实时 microSD 中

本教程假设使用 \jvversion{1.3} 或更高版本。

因为我们需要交叉编译 C++ 代码以便在 JeVois 处理器上执行，所以本教程仅适用于 Linux。

请参阅 \ref ProgrammerPythonDice 了解该算法在 Python + OpenCV（Linux、Windows 或 Mac 主机）中的实现。

准备工作 
-------------

- 查看 \ref ProgrammerSetup ，以便您熟悉：
  + 将最新的 microSD 映像刷入物理卡
  + 将 JeVois 连接到主机并启动它
  + 从 JeVois 抓取视频并选择不同的分辨率
  + 使用串行 USB 链接与 JeVois 通信，并使用 JeVois 命令行界面
  + 将 JeVois 内的 microSD 导出到您的主机

设置新的 C++ 模块 
------------------------------

最简单的入门方法是获取 JeVois github https://github.com/jevois/samplemodule 中的 \b samplemodule 的副本并对其进行修改。

如果您已经安装了 \b jevois-sdk 并按照 \ref ProgrammerSetup 中的说明进行操作，则应该使用脚本 `jevois-create-module`，它将从 GitHub 获取示例代码，并且还会立即更改类和文件的名称以匹配我们新模块的名称：用法是 `jevois-create-module <VendorName> <ModuleName>`，所以这里我们只需运行：

\verbatim
cd
jevois-create-module Tutorial DiceCounter
\endverbatim

您现在应该有以下内容：
\verbatim
dicecounter
├── CMakeLists.txt
├── COPYING
├── INSTALL
├── README
├── rebuild-host.sh
├── rebuild-platform.sh
└── src
    └── Modules
        └── DiceCounter
            ├── DiceCounter.C
            ├── icon.png
            ├── postinstall
            └── screenshot1.png
\endverbatim

算法
-------------

上述文章中提到的原始模块的作者 Yohann Payet 向我们发送了他的代码，该代码用 C++ 编写，如下所示（这是独立代码，不适用于 JeVois；在本教程中，我们将对其进行转换以适应 JeVois）：

\code
// Created by Yohann Payet (mechanical/embedded systems engineer)
// Using opencv,c++
// Contact Y.Payet@hotmail.com

#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/features2d.hpp"
#include <iostream>

int main() {
    cv::Mat im_with_keypoints; std::vector<cv::KeyPoint> keypoints;
    cv::Mat grayImage, camFrame, kernel;
    int morphBNo2 = 2;
    char str[200];


    //Setting detector parameters
    cv::SimpleBlobDetector::Params params;
    params.filterByCircularity = true;
    params.filterByArea = true;
    params.minArea = 200.0f;

    //Creating a detector object
    cv::Ptr<cv::SimpleBlobDetector> detector = cv::SimpleBlobDetector::create(params);

    //video capture settings
    cv::VideoCapture cap(1); // open the default camera
    cap.set(CV_CAP_PROP_FRAME_WIDTH, 640);
    cap.set(CV_CAP_PROP_FRAME_HEIGHT, 480);

    //checking video stream
    if (!cap.isOpened()) {  // check if we succeeded
        std::cout << ("Failure to open camera") << "\n";
        std::cin.get();
    }
    else {
        for (;;) {

            // get a new frame from camera
            cap >> camFrame;

            //converting video to single channel grayscale
            cv::cvtColor(camFrame, grayImage, CV_BGR2GRAY);
            grayImage.convertTo(grayImage, CV_8U);

            //filter noise
            cv::GaussianBlur(grayImage, grayImage, cvSize(5, 5), 0, 0);

            //apply automatic threshold
            cv::threshold(grayImage, grayImage, 0.0, 255, cv::THRESH_BINARY_INV | cv::THRESH_OTSU);

            //background area
            cv::dilate(grayImage, grayImage, kernel, cv::Point(-1, -1), morphBNo2);
            cv::Mat image(grayImage.rows, grayImage.cols, CV_8U, cv::Scalar(255, 255, 255));
            cv::Mat invBack2 = image - grayImage;


            //blob detection
            detector->detect(invBack2, keypoints);
            int nrOfBlobs = keypoints.size();

            // draw keypoints
            cv::drawKeypoints(camFrame, keypoints, im_with_keypoints, cv::Scalar(0, 0, 255),
	    		      cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);

            //text only appears if at least 1 blob is detected
            if (nrOfBlobs >0 ) {
                sprintf(str, "total pips: %d ", nrOfBlobs);
                cv::putText(im_with_keypoints, str, cv::Point2f(10, 25), cv::FONT_HERSHEY_PLAIN,
		            2, cv::Scalar(0, 255, 255, 255));
            }

            //show image
            imshow("keypoints", im_with_keypoints);
            std::cout << "number of pips: " << nrOfBlobs << std::endl;

            //hit esc to quit
            if (cv::waitKey(1) == 27)  break;

        }
    }

    return 0 ;
}
\endcode


我们现在的任务是：

- 使用 JeVois 输入帧而不是 OpenCV 视频捕获对象
- 使用 JeVois 框架通过 USB 将结果图像发送到主机，而不是使用 OpenCV HighGUI 显示它们

决定捕获和输出分辨率 
------------------------------------------

此算法是为 640x480 分辨率编写的。让我们也将其用于我们的模块中。我们编辑 <b>~/dicecounter/src/Modules/DiceCounter/postinstall</b> 如下：

\verbatim
jevois-add-videomapping YUYV 640 480 17 YUYV 640 480 17 Tutorial DiceCounter
\endverbatim

在我们将新模块安装到 microSD 后，JeVois 相机将运行 \b postinstall 脚本。我们的模块所需的视频映射（在 \b postinstall 中定义）将添加到 microSD 上的主 \b videomappings.cfg 文件中。请注意，\b postinstall 仅适用于平台硬件。要将视频映射添加到主机配置，只需在主机上运行上述命令（使用 sudo）。

请注意，我们在这里选择 17 帧/秒作为帧速率的初始猜测。由于 640x480 是一种流行的分辨率，这也将使我们能够避免与使用相同分辨率但速率为 30 帧/秒或其他的其他模块发生冲突。一旦我们知道该算法在 JeVois 上运行的速度有多快，我们稍后就会调整此速率。

首次导入至实时 microSD 
------------------------------

JeVois \b samplemodule 开箱即用，因此如果我们没有引入任何错误，我们的模块也应该可以运行。

通过 CMake 自动编译并安装模块到连接的 JeVois 相机内的实时 microSD，只需连接 JeVois 并让其启动，然后输入：

\verbatim
cd ~/dicecounter
./rebuild-platform.sh --live
\endverbatim

这将指示 JeVois 将其 microSD 作为虚拟闪存驱动器导出到主机，复制所需文件，然后弹出驱动器以重新启动 JeVois。一旦 JeVois 重新启动，该模块即可使用。

你应该看到如下输出：

\verbatim
itti@iLab1:~/dicecounter$ ./rebuild-platform.sh --live
-- JeVois version 1.2.3
-- JEVOIS_PLATFORM: ON
-- JEVOIS_VENDOR: Tutorial
-- JeVois microSD card mount point: /media/itti/JEVOIS
-- JeVois serial-over-USB device: /dev/ttyACM0
-- JEVOIS_MODULES_TO_STAGING: OFF
-- JEVOIS_MODULES_TO_MICROSD: OFF
-- JEVOIS_MODULES_TO_LIVE: ON
-- Install prefix for executable programs: /var/lib/jevois-build/usr
-- Host path to jevois modules root: /var/lib/jevois-microsd
-- The C compiler identification is GNU 6.1.0
-- The CXX compiler identification is GNU 6.1.0
-- Check for working C compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-gcc
-- Check for working C compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-g++
-- Check for working CXX compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-g++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- JeVois SDK root: /lab/itti/jevois/software/jevois-sdk
-- Adding compilation directives for C++ module DiceCounter base src/Modules
-- Configuring done
-- Generating done
-- Build files have been written to: /lab/itti/dicecounter/pbuild
Scanning dependencies of target modinfo_DiceCounter
[ 50%] Generating ../src/Modules/DiceCounter/modinfo.yaml, ../src/Modules/DiceCounter/modinfo.html
[ 50%] Built target modinfo_DiceCounter
Scanning dependencies of target DiceCounter
[100%] Building CXX object CMakeFiles/DiceCounter.dir/src/Modules/DiceCounter/DiceCounter.C.o
Linking CXX shared library DiceCounter.so
[100%] Built target DiceCounter
[ 50%] Built target modinfo_DiceCounter
[100%] Built target DiceCounter
Install the project...
-- Install configuration: ""
JeVois smart camera virtual USB ready at /media/itti/JEVOIS
-- Installing: /media/itti/JEVOIS/modules/Tutorial/DiceCounter
-- Installing: /media/itti/JEVOIS/modules/Tutorial/DiceCounter/postinstall
-- Installing: /media/itti/JEVOIS/modules/Tutorial/DiceCounter/screenshot1.png
-- Installing: /media/itti/JEVOIS/modules/Tutorial/DiceCounter/icon.png
-- Installing: /media/itti/JEVOIS/modules/Tutorial/DiceCounter/DiceCounter.so
-- Removed runtime path from "/media/itti/JEVOIS/modules/Tutorial/DiceCounter/DiceCounter.so"
JeVois smart camera virtual USB disk ejected -- rebooting JeVois
\endverbatim

尝试初始示例模块 
------------------------------------

启动视频捕捉软件，将其设置为 640x480 @@ 17fps。您应该看到示例 Python 模块正在运行，但使用的是我们的新名称：

\image html cdice1.png

实现模块 
-----------------------

我们只需编辑 \b DiceCounter.C 即可使用上述代码。主要变化如下：

- 我们将获得一个 YUYv 格式的 jevois::RawImage 作为输入
- 在两个并行线程中，我们将：
  + 将完整的输入图像复制到 USB 输出缓冲区，以显示给用户
  + 将其转换为灰度并对其进行处理以检测骰子点数
- 我们最终将检测到的点数绘制到输出图像中，并通过 USB 发送。

结果代码如下：

\code
//! Counting dice pips
/*! This module can help you automate counting your dice values, for example when playing games that involve throwing
    multiple dice.

    This application scenario was suggested by JeVois user mapembert at the [JeVois Tech Zone](http://jevois.org/qa)
    in this post:

    http://jevois.org/qa/index.php?qa=328

    The code implemented by this module is a modified version of original code (mentioned in the above post) contributed
    by Yohann Payet.

    @author Laurent Itti

    @videomapping YUYV 640 480 17.0 YUYV 640 480 17.0 SampleVendor DiceCounter
    @email sampleemail\@samplecompany.com
    @address 123 First Street, Los Angeles, CA 90012
    @copyright Copyright (C) 2017 by Sample Author
    @mainurl http://samplecompany.com
    @supporturl http://samplecompany.com/support
    @otherurl http://samplecompany.com/about
    @license GPL v3
    @distribution Unrestricted
    @restrictions None */
class DiceCounter : public jevois::Module
{
  public:
    //! Constructor
    DiceCounter(std::string const & instance) : jevois::Module(instance)
    {
      // Setting detector parameters
      cv::SimpleBlobDetector::Params params;
      params.filterByCircularity = true;
      params.filterByArea = true;
      params.minArea = 200.0f;

      // Creating a detector object
      itsDetector = cv::SimpleBlobDetector::create(params);
    }

    //! Virtual destructor for safe inheritance
    virtual ~DiceCounter() { }

    //! Processing function
    virtual void process(jevois::InputFrame && inframe, jevois::OutputFrame && outframe) override
    {
      static jevois::Timer timer("processing");

      // Wait for next available camera image:
      jevois::RawImage const inimg = inframe.get(); unsigned int const w = inimg.width, h = inimg.height;

      timer.start();

      // We only support YUYV pixels in this example, any resolution:
      inimg.require("input", inimg.width, inimg.height, V4L2_PIX_FMT_YUYV);

      // Start a thread to wait for output image anc opy input into output:
      jevois::RawImage outimg;
      std::future<void> fut = std::async(std::launch::async, [&]() {
          // Wait for an image from our gadget driver into which we will put our results:
          outimg = outframe.get();

          // Enforce that the input and output formats and image sizes match:
          outimg.require("output", w, h, inimg.fmt);
      
          // Just copy the pixel data over:
          jevois::rawimage::paste(inimg, outimg, 0, 0);
        });

      // Detect dice pips: First convert input to grayscale:
      cv::Mat grayImage = jevois::rawimage::convertToCvGray(inimg);

      // filter noise
      cv::GaussianBlur(grayImage, grayImage, cvSize(5, 5), 0, 0);

      // apply automatic threshold
      cv::threshold(grayImage, grayImage, 0.0, 255, cv::THRESH_BINARY_INV | cv::THRESH_OTSU);

      // background area
      cv::Mat kernel; // not initialized??
      int const morphBNo2 = 2;
      cv::dilate(grayImage, grayImage, kernel, cv::Point(-1, -1), morphBNo2);
      cv::Mat image(grayImage.rows, grayImage.cols, CV_8U, cv::Scalar(255, 255, 255));
      cv::Mat invBack2 = image - grayImage;

      // blob detection
      std::vector<cv::KeyPoint> keypoints;
      itsDetector->detect(invBack2, keypoints);
      int nrOfBlobs = keypoints.size();

      // Wait until our other thread is done:
      fut.get();

      // Let camera know we are done processing the input image:
      inframe.done();
      
      // draw keypoints
      for (cv::KeyPoint const & kp : keypoints)
        jevois::rawimage::drawCircle(outimg, int(kp.pt.x + 0.5F), int(kp.pt.y + 0.5F), int(kp.size * 0.5F),
                                     2, jevois::yuyv::LightGreen);

      // Show number of detected pips:
      jevois::rawimage::writeText(outimg, "JeVois dice counter: " + std::to_string(nrOfBlobs) + " pips",
                                  3, 3, jevois::yuyv::White);
      
      // Show processing fps:
      std::string const & fpscpu = timer.stop();
      jevois::rawimage::writeText(outimg, fpscpu, 3, h - 13, jevois::yuyv::White);
    
      // Send the output image with our processing results to the host over USB:
      outframe.send();
    }

  private:
    cv::Ptr<cv::SimpleBlobDetector> itsDetector;
};

// Allow the module to be loaded as a shared object (.so) file:
JEVOIS_REGISTER_MODULE(DiceCounter);
\endcode



结果  -  -  - 

你应该看到类似这样的内容：

\image html cdice2.png

请注意，此算法在 JeVois 上运行速度有点慢，大约每秒 8 帧。可以相应地调整视频映射。

有趣的是，此实现的运行速度与 \ref ProgrammerPythonDice 中开发的 Python 实现的速度大致相同，尽管我们在该 Python 教程中假设我们可能能够让 C++ 代码运行得更快！原因如下：在 Python 代码中，从 YUYV 到 BGR 和到灰度（在 `img = inframe.getCvBGR()` 和 `grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)` 的图像转换，以及在 `outframe.sendCvBGR(im_with_keypoints)` 中从 BGR 到 YUYV 的图像转换不计入 Python 模块中的处理时间，但所有转换都由 C++ 实现的计时器计算。因此，包括所有转换在内的 C++ 算法的运行速度与不包括任何转换的 Python 实现的核心一样快。无论如何，看起来 JeVois 和 OpenCV Python 绑定确实非常高效！

鉴于任何人都不太可能需要此应用程序的任何快速帧速率（因为掷骰子的频率并不高），因此这里无需进一步优化。低帧速率将使相机传感器即使在低光照条件下也能表现良好。

包装模块
------------------

要创建一个可以发送给朋友的精美打包模块，只需输入：

\verbatim
./rebuild-platform.sh
\endverbatim

它将安装到模块中的目录 \b jvpkg 中：

\verbatim
Install the project...
-- Install configuration: ""
-- Installing: /lab/itti/dicecounter/jvpkg/modules/Tutorial/DiceCounter
-- Installing: /lab/itti/dicecounter/jvpkg/modules/Tutorial/DiceCounter/postinstall
-- Installing: /lab/itti/dicecounter/jvpkg/modules/Tutorial/DiceCounter/screenshot1.png
-- Installing: /lab/itti/dicecounter/jvpkg/modules/Tutorial/DiceCounter/icon.png
-- Installing: /lab/itti/dicecounter/jvpkg/modules/Tutorial/DiceCounter/DiceCounter.so
-- Removed runtime path from "/lab/itti/dicecounter/jvpkg/modules/Tutorial/DiceCounter/DiceCounter.so"
\endverbatim

最后你输入：

\verbatim
cd pbuild
make jvpkg
\endverbatim

这将创建 <b>~/dicecounter/Tutorial_dicecounter.jvpkg</b>

您可以将该文件发送给您的朋友，并告诉他们将其复制到 microSD 上的 <b>JEVOIS:/packages/</b>。下次 JeVois 重新启动时，它将解压、安装、配置和删除该软件包，然后新模块即可使用。

最后说明 
----------

该模块现已集成到 \b jevoisbase 中，作为 \jvmod{DiceCounter} 模块，输出分辨率为 640x480 @@ 7.5 fps。

*/

