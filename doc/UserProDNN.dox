/*! \page UserProDNN 将深度神经网络转换为 JeVois-Pro


模型转换 
==================

JeVois 的主要文档提供了有关如何为 \jvpro 可用的各种加速器转换模型的说明和示例：

- \ref UserDNNoverview
- \ref UserDNNopencv
- \ref UserDNNnpu
- \ref UserDNNspu
- \ref UserDNNtpu
- \ref UserDNNvpu

在 Python 中编写自定义 preproc/network/postproc 
=====================================================

JeVois 框架已经具有用于分类、YOLO、SSD、YuNet 等的后处理器，但如果您要导入不同类型的网络，则可能需要自己的自定义预处理器。最简单的方法是用 Python 实现它，因为网络创建者通常还会提供 Python 代码来进行后处理。

看看下面的例子：

- 示例预处理器：[PyPreBlob.py](https://github.com/jevois/jevoisbase/blob/master/share-jevoispro/pydnn/pre/PyPreBlob.py)

- 使用 OpenCV 的示例网络推理：[PyNetOpenCV.py](https://github.com/jevois/jevoisbase/blob/master/share-jevoispro/pydnn/net/PyNetOpenCV.py)

- 示例分类后处理器：[PyPostClassify.py](https://github.com/jevois/jevoisbase/blob/master/share-jevoispro/pydnn/post/PyPostClassify.py)

- 指定 model zoo 条目时如何加载这些内容：查看 [opencv.yml](https://github.com/jevois/jevoisbase/blob/master/share-jevoispro/dnn/opencv.yml) 中的 "Python version of SqueezeNet 1.1"
  + 要使用 Python 预处理程序：将 \b preproc 设置为 Python，然后将 \b pypre 设置为您的 Python 代码
  + 要使用 Python 网络：将 \b nettype 设置为 Python，然后将 \b pynet 设置为您的 Python 代码
  + 要使用 Python 后处理程序：将 \b postproc 设置为 Python，然后将 \b pypost 设置为您的 Python 代码

\note 如果网络类型为 Python，并且 preproc 或 postproc 也是 Python，则无法进行异步处理（网络在单独的线程中运行），因为 Python 解释器不可重入。通常，C++ 预处理器和网络应该适用于大多数模型，并且您通常只需要自定义 Python 后处理器。然后，由于网络是从 C++ 运行的，因此它可以在并行线程中运行而不会出现问题。

有关自定义后处理的更多详细信息 
-----------------------------------------

JeVois 中的通用后处理器定义位于 [PostProcessor C++ 虚拟基类](https://github.com/jevois/jevois/blob/master/include/jevois/DNN/PostProcessor.H) 中。您基本上需要在其中实现标记为纯虚（`= 0`）函数：

- `freeze(bool doit)`：由 JeVois 核心调用，用于冻结或解冻模块的 JeVois 参数，这些参数不应允许用户在运行时更改。在实现中，您通常只需对那些应该在运行时冻结的参数调用 `freeze(doit)`，并跳过那些用户可以在运行时使用的参数。

- `process(std::vector<cv::Mat> const & outs, PreProcessor * preproc)`：由 JeVois 核心调用，使用包含从网络接收的输出的数组列表，通常反量化为 float32。在这里，您应该解析这些并存储解码的结果以供以后在 `report()` 中使用。给定的 \b preproc 可用于帮助将作为输入传递给网络的 blob 的坐标缩放回相机捕获的原始图像。

- `report(jevois::StdModule * mod, jevois::RawImage * outimg, jevois::OptGUIhelper * helper, bool overlay, bool idle)`：报告上次调用 process() 时获得的解析结果，例如通过绘制框或编写一些文本消息。如果您获得非空的 \b helper ，则应使用帮助程序提供给您的支持 OpenGL 的函数绘制输出。如果您获得非空的 outimg，则用户正在使用您的模块在 \a Legacy 模式下通过 USB 传输流式视频，您需要使用 jevois::RawImage 绘制函数将输出绘制到该图像中。对于 JeVois-Pro，您可以跳过该传统模式，因为大多数人都希望使用新的 GUI/OpenGL 模式。

`process()` 和 `report()` 是分开的，因为它们可能以不同的速率调用：report() 必须在每一帧上调用，以便绘制 GUI 和显示。但 process() 只会在每次网络完成输入处理时调用。如果您的网络仅以 5 fps 运行推理，则 process() 将以 5 fps 调用，而 report() 则以 30 fps 调用。

\note 您应该在调用 process() 之前就准备好调用 report()。如果网络加载或初始化速度较慢，通常就会出现这种情况，我们不想阻塞显示和 GUI，因此在等待网络时我们仍会以 30 fps 的速度调用 report()。因此，您应该在构造函数中将要报告的内容初始化为合理的默认值。

现在你应该能够理解 [PyPostClassify.py](https://github.com/jevois/jevoisbase/blob/master/share-jevoispro/pydnn/post/PyPostClassify.py) 中发生了什么

在某些后处理器中，您可能需要绘制框、圆圈、覆盖图等。查看 [PythonModule.H 中的 GUIhelperPython 类](https://github.com/jevois/jevois/blob/master/include/jevois/Core/PythonModule.H) 以获取可用函数 GUIhelper::i2d()、GUIhelper::drawLine()、GUIhelper::drawRect()、GUIhelper::drawPoly()、GUIhelper::drawCircle()、GUIhelper::itext()、GUIhelper::d2i() 等的签名。

请注意，这些函数从 GUI 继承了一些全局参数。例如，当您绘制填充的矩形或圆形时，填充的透明度或轮廓的粗细不受您的控制，而由用户通过 GUI 的参数 \p fillalpha、\p linethick 等进行控制（要查看这些参数，请切换到 GUI 的 \b Parameters 选项卡，启用右上角的 <b>Show System Parameters</b>，然后查看 <b>Graphical interface options</b> ）。

*/

