/*! \page ProgrammerPythonDice JeVois python 教程：骰子计数模块

这里我们开发了一个简单的 Python+OpenCV 视觉模块，用于计算 JeVois 收到的骰子上的总点数。该应用场景由 JeVois 用户 mapembert 在 [JeVois Tech Zone](http://jevois.org/qa) 的这篇文章中提出：

http://jevois.org/qa/index.php?qa=328

在本教程中，您将学习：

- 如何从头开始为 JeVois 创建新的 Python 机器视觉模块
- 如何用 Python 实现骰子计数算法
- 如何将新模块安装到实时 microSD 中

本教程假设使用 \jvversion{1.3} 或更高版本。

请参阅 \ref ProgrammerDice 了解该算法在 C++ OpenCV（仅限 Linux 主机）中的实现。

准备工作 
-------------

- 查看 \ref ProgrammerPythonLive ，以便您熟悉以下内容：
  + 将最新的 microSD 映像刷入物理卡
  + 将 JeVois 连接到主机并启动它
  + 从 JeVois 抓取视频并选择不同的分辨率
  + 使用串行 USB 链接与 JeVois 通信，并使用 JeVois 命令行界面
  + 将 JeVois 内的 microSD 导出到主机
  + 在 JeVois 内的 microSD 上实时编辑 Python 代码

设置新的 Python 模块 
------------------------------

最简单的入门方法是获取 JeVois github https://github.com/jevois/samplepythonmodule 中的 \b samplepythonmodule 的副本：

- Windows 和 Mac 用户：从上述 URL 获取 \b samplepythonmodule 存储库的副本。您基本上会执行类似于以下的操作：
  \verbatim
  git clone https://github.com/jevois/samplepythonmodule.git
  \endverbatim
  之后，您应该：
  + 将目录 samplepythonmodule 重命名为 pythondicecounter
  + 编辑 CMakeLists.txt 以更改模块名称和供应商名称
  + 将 src/Modules/SamplePythonModule 重命名为 src/Modules/PythonDiceCounter
  + 将 src/Modules/PythonDiceCounter/PythonDiceCounter.py 中的类名称更改为 PythonDiceCounter

- Linux: 如果您已经安装了 \b jevois-sdk 并按照 \ref ProgrammerSetup 中的说明进行操作，则应使用脚本 `jevois-create-python-module`，该脚本将从 GitHub 获取相同的示例代码，并且还将立即更改类和文件的名称以匹配我们新模块的名称：用法是 `jevois-create-python-module <VendorName> <ModuleName>`，因此这里我们只需运行：
  \verbatim
  cd
  jevois-create-python-module Tutorial PythonDiceCounter
  \endverbatim 
  您现在应该有以下内容：
  \verbatim
  pythondicecounter
  ├── CMakeLists.txt
  ├── COPYING
  ├── INSTALL
  ├── README.md
  ├── rebuild-host.sh
  ├── rebuild-platform.sh
  └── src
      └── Modules
          └── PythonDiceCounter
              ├── postinstall
              └── PythonDiceCounter.py
  \endverbatim

\note 用 Python 编写的 Vision 模块无需编译。CMakeLists.txt 可帮助您：
- 安装到 JeVois 内部的实时 microSD 卡上
- 生成在线文档
- 创建 \b jvpkg 包，其中包含模块，只需将该包复制到 JeVois 的 microSD 上的 <b>JEVOIS:/packages/</b> 即可让朋友试用。下次 JeVois 重新启动时，它将解压 jvpkg 文件并安装包。

算法
-------------

上述文章中提到的原始模块的作者 Yohann Payet 向我们发送了他的代码，该代码用 C++ 编写，如下所示（这是独立代码，不适用于 JeVois；在本教程中，我们将把它转换为 Python 并使其适应 JeVois）：

\code
// Created by Yohann Payet (mechanical/embedded systems engineer)
// Using opencv,c++
// Contact Y.Payet@hotmail.com

#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/features2d.hpp"
#include <iostream>

int main() {
    cv::Mat im_with_keypoints; std::vector<cv::KeyPoint> keypoints;
    cv::Mat grayImage, camFrame, kernel;
    int morphBNo2 = 2;
    char str[200];


    //Setting detector parameters
    cv::SimpleBlobDetector::Params params;
    params.filterByCircularity = true;
    params.filterByArea = true;
    params.minArea = 200.0f;

    //Creating a detector object
    cv::Ptr<cv::SimpleBlobDetector> detector = cv::SimpleBlobDetector::create(params);

    //video capture settings
    cv::VideoCapture cap(1); // open the default camera
    cap.set(CV_CAP_PROP_FRAME_WIDTH, 640);
    cap.set(CV_CAP_PROP_FRAME_HEIGHT, 480);

    //checking video stream
    if (!cap.isOpened()) {  // check if we succeeded
        std::cout << ("Failure to open camera") << "\n";
        std::cin.get();
    }
    else {
        for (;;) {

            // get a new frame from camera
            cap >> camFrame;

            //converting video to single channel grayscale
            cv::cvtColor(camFrame, grayImage, CV_BGR2GRAY);
            grayImage.convertTo(grayImage, CV_8U);

            //filter noise
            cv::GaussianBlur(grayImage, grayImage, cvSize(5, 5), 0, 0);

            //apply automatic threshold
            cv::threshold(grayImage, grayImage, 0.0, 255, cv::THRESH_BINARY_INV | cv::THRESH_OTSU);

            //background area
            cv::dilate(grayImage, grayImage, kernel, cv::Point(-1, -1), morphBNo2);
            cv::Mat image(grayImage.rows, grayImage.cols, CV_8U, cv::Scalar(255, 255, 255));
            cv::Mat invBack2 = image - grayImage;


            //blob detection
            detector->detect(invBack2, keypoints);
            int nrOfBlobs = keypoints.size();

            // draw keypoints
            cv::drawKeypoints(camFrame, keypoints, im_with_keypoints, cv::Scalar(0, 0, 255),
	    		      cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);

            //text only appears if at least 1 blob is detected
            if (nrOfBlobs >0 ) {
                sprintf(str, "total pips: %d ", nrOfBlobs);
                cv::putText(im_with_keypoints, str, cv::Point2f(10, 25), cv::FONT_HERSHEY_PLAIN,
		            2, cv::Scalar(0, 255, 255, 255));
            }

            //show image
            imshow("keypoints", im_with_keypoints);
            std::cout << "number of pips: " << nrOfBlobs << std::endl;

            //hit esc to quit
            if (cv::waitKey(1) == 27)  break;

        }
    }

    return 0 ;
}
\endcode


我们现在的任务是：

- 将 C++ 调用转换为 OpenCV 函数，再转换为 Python 调用
- 使用 JeVois 输入帧，而不是 OpenCV 视频捕获对象
- 使用 JeVois 框架通过 USB 将结果图像发送到主机，而不是使用 OpenCV HighGUI 显示它们

决定捕获和输出分辨率 
------------------------------------------

此算法是为 640x480 分辨率编写的。让我们也将其用于我们的模块中。我们编辑 <b>~/pythondicecounter/src/Modules/PythonDiceCounter/postinstall</b> 如下：

\verbatim
jevois-add-videomapping YUYV 640 480 22 YUYV 640 480 22 Tutorial PythonDiceCounter
\endverbatim

在我们将新模块安装到 microSD 后，JeVois 相机将运行 \b postinstall 脚本。我们的模块所需的视频映射（在 \b postinstall 中定义）将添加到 microSD 上的主 \b videomappings.cfg 文件中。请注意，\b postinstall 仅适用于平台硬件。要将视频映射添加到主机配置，只需在主机上运行上述命令（使用 sudo）。

请注意，我们在这里选择 22 帧/秒作为帧速率的初始猜测。由于 640x480 是一种流行的分辨率，这也将使我们能够避免与使用相同分辨率但速率为 30 帧/秒或其他的其他模块发生冲突。一旦我们知道该算法在 JeVois 上运行的速度有多快，我们稍后就会调整此速率。

首次导入至实时 microSD 
------------------------------

JeVois \b samplepythonmodule 开箱即用，因此如果我们没有引入任何错误，我们的模块也应该可以运行。

- 在 Mac 和 Windows 上：
  + 在 microSD 上为我们的新供应商名称 \a Tutorial 创建目录 <b>JEVOIS:/modules/Tutorial</b>
  + 在 microSD 上为我们的新模块创建目录 <b>JEVOIS:/modules/Tutorial/PythonDiceCounter</b>
  + 将文件 \b postinstall 和 \b PythonDiceCounter.py 从 <b>pythondicecounter/src/Modules/PythonDiceCounter/</b> 复制到 microSD 上的 <b>JEVOIS:/modules/Tutorial/PythonDiceCounter/</b>

- 在 Linux 上：这已通过 CMake 自动完成，只需连接 JeVois 并让其启动，然后输入：
  \verbatim
  cd ~/pythondicecounter
  ./rebuild-platform.sh --live
  \endverbatim
  这将指示 JeVois 将其 microSD 作为虚拟闪存驱动器导出到主机，复制所需的文件，然后弹出驱动器以重新启动 JeVois。 JeVois 重新启动后，该模块即可使用。

  您应该看到如下输出：
\verbatim
itti@iLab1:~/pythondicecounter$   ./rebuild-platform.sh --live
[sudo] password for itti: 
-- JeVois version 1.2.3
-- JEVOIS_PLATFORM: ON
-- JEVOIS_VENDOR: Tutorial
-- JeVois microSD card mount point: /media/itti/JEVOIS
-- JeVois serial-over-USB device: /dev/ttyACM0
-- JEVOIS_MODULES_TO_STAGING: OFF
-- JEVOIS_MODULES_TO_MICROSD: OFF
-- JEVOIS_MODULES_TO_LIVE: ON
-- Install prefix for executable programs: /var/lib/jevois-build/usr
-- Host path to jevois modules root: /var/lib/jevois-microsd
-- The C compiler identification is GNU 6.1.0
-- The CXX compiler identification is GNU 6.1.0
-- Check for working C compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-gcc
-- Check for working C compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-g++
-- Check for working CXX compiler: /lab/itti/jevois/software/jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-g++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- JeVois SDK root: /lab/itti/jevois/software/jevois-sdk
-- Adding setup directives for Python module PythonDiceCounter base src/Modules
-- Configuring done
-- Generating done
-- Build files have been written to: /lab/itti/pythondicecounter/pbuild
Scanning dependencies of target modinfo_PythonDiceCounter
[100%] Generating ../src/Modules/PythonDiceCounter/modinfo.yaml, ../src/Modules/PythonDiceCounter/modinfo.html
[100%] Built target modinfo_PythonDiceCounter
[100%] Built target modinfo_PythonDiceCounter
Install the project...
-- Install configuration: ""
JeVois smart camera virtual USB ready at /media/itti/JEVOIS
-- Installing: /media/itti/JEVOIS/modules/Tutorial/PythonDiceCounter
-- Installing: /media/itti/JEVOIS/modules/Tutorial/PythonDiceCounter/postinstall
-- Installing: /media/itti/JEVOIS/modules/Tutorial/PythonDiceCounter/PythonDiceCounter.py
JeVois smart camera virtual USB disk ejected -- rebooting JeVois
\endverbatim

尝试初始示例模块 
------------------------------------

启动视频捕捉软件，将其设置为 640x480 @@ 22fps。您应该看到示例 Python 模块正在运行，但使用的是我们的新名称：

\image html dice1.png

实现模块 
-----------------------

从这里开始，我们有两种实现模块的基本方法：

- 在主机上编辑 PythonDiceCounter.py，并偶尔将其复制到实时 JeVois microSD
- 直接在实时 microSD 上编辑

在这两种情况下，我们将使用 \c usbsd JeVois 命令将 JeVois 内的 microSD 导出为虚拟闪存驱动器，如用户教程 \ref UserUSBSD 中所述，以及程序员教程 \ref ProgrammerPythonLive 中所述

让我们将 C++ 代码转换为 Python。快速网络搜索 'python SimpleBlobDetector' 会显示以下出色的教程，它们将帮助我们进行转换：
- https://www.learnopencv.com/blob-detection-using-opencv-python-c/
- https://www.makehardware.com/2016/05/19/blob-detection-with-python-and-opencv/

如果有疑问，我们也可以搜索网络；例如，要了解如何将 `cv::GaussianBlur(...)` 翻译成 Python，我们只需搜索 `cv2.GaussianBlur` 即可找到 Python 语法。

这是我们的第一次尝试：

\code{.py}
import libjevois as jevois
import cv2
import numpy as np

## Count the number of pips on dice seen by JeVois
#
# This module can help you automate counting your dice values, for example when playing games that involve throwing
# multiple dice.
#
# @author Laurent Itti
# 
# @videomapping YUYV 640 480 22.0 YUYV 640 480 22.0 JeVois PythonDiceCounter
# @email itti\@usc.edu
# @address University of Southern California, HNB-07A, 3641 Watt Way, Los Angeles, CA 90089-2520, USA
# @copyright Copyright (C) 2017 by Laurent Itti, iLab and the University of Southern California
# @mainurl http://jevois.org
# @supporturl http://jevois.org/doc
# @otherurl http://iLab.usc.edu
# @license GPL v3
# @distribution Unrestricted
# @restrictions None
# @ingroup modules
class PythonDiceCounter:
    # ###################################################################################################
    ## Constructor
    def __init__(self):
        self.morphBNo2 = 2
        
        # Instantiate a JeVois Timer to measure our processing framerate:
        self.timer = jevois.Timer("dice", 50, jevois.LOG_DEBUG)

        # Instantiate a circular blob detector:
        params = cv2.SimpleBlobDetector_Params()
        params.filterByCircularity = True
        params.filterByArea = True
        params.minArea = 200.0

        self.detector = cv2.SimpleBlobDetector_create(params)

        # Create a morpho kernel (this was not in the original code?)
        self.kernel = np.ones((5,5), np.uint8)
        
    # ###################################################################################################
    ## Process function with no USB output
    #def processNoUSB(self, inframe):
    #    jevois.LFATAL("process no usb not implemented")

    # ###################################################################################################
    ## Process function with USB output
    def process(self, inframe, outframe):
        # Get the next camera image (may block until it is captured) and convert it to OpenCV BGR (for color output):
        img = inframe.getCvBGR()

        # Also convert it to grayscale for processing:
        grayImage = cv2.cvtColor(img, cv2.CV_BGR2GRAY)
        
        # Get image width, height:
        height, width = grayImage.shape

        # Start measuring image processing time (NOTE: does not account for input conversion time):
        self.timer.start()

        # filter noise
        grayImage = cv2.GaussianBlur(grayImage, (5, 5), 0, 0);

        # apply automatic threshold
        grayImage = cv2.threshold(grayImage, 0.0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)

        # background area
        grayImage = cv2.dilate(grayImage, self.kernel, (-1, -1), self.morphBNo2)
        invBack2 = 255 - grayImage

        # blob detection
        keypoints = self.detector.detect(invBack2)
        nrOfBlobs = keypoints.shape()

        # draw keypoints
        im_with_keypoints = cv2.drawKeypoints(img, keypoints, np.array([]), (0, 0, 255),
                                              cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
 
        # text only appears if at least 1 blob is detected
        if nrOfBlobs > 0:
            cv2.putText(im_with_keypoints, "total pips: {}".format(nrOfBlobs), (10, 25), cv2.FONT_HERSHEY_PLAIN,
                        2, (0, 255, 255, 255))

        # Write frames/s info from our timer (NOTE: does not account for output conversion time):
        fps = self.timer.stop()
        cv2.putText(im_with_keypoints, fps, (3, height - 6), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                    (255,255,255), 1, cv2.LINE_AA)
    
        # Convert our BGR image to video output format and send to host over USB:
        outframe.sendCvBGR(im_with_keypoints)
\endcode


让我们通过打开视频捕捉软件尝试一下，我们发现该代码存在一些问题：

\image html dice2.png

上述代码中还有许多其他翻译错误，我们可以使用 JeVois 视频错误消息轻松检测和修复这些错误，如上图所示。也许最难调试的是使用 `+` 运算符来组合 `cv2..threshold()` 调用中的标志，而不是 C++ 的 `|` 运算符，同时注意 `cv2.threshold()` 如何具有两个返回值。

结果  
------

经过调试后最终的代码为：

\code{.py}
import libjevois as jevois
import cv2
import numpy as np

## Count the number of pips on dice seen by JeVois
#
# This module can help you automate counting your dice values, for example when playing games that involve throwing
# multiple dice.
#
# @author Laurent Itti
# 
# @videomapping YUYV 640 480 22.0 YUYV 640 480 22.0 JeVois PythonDiceCounter
# @email itti\@usc.edu
# @address University of Southern California, HNB-07A, 3641 Watt Way, Los Angeles, CA 90089-2520, USA
# @copyright Copyright (C) 2017 by Laurent Itti, iLab and the University of Southern California
# @mainurl http://jevois.org
# @supporturl http://jevois.org/doc
# @otherurl http://iLab.usc.edu
# @license GPL v3
# @distribution Unrestricted
# @restrictions None
# @ingroup modules
class PythonDiceCounter:
    # ###################################################################################################
    ## Constructor
    def __init__(self):
        self.morphBNo2 = 2
        
        # Instantiate a JeVois Timer to measure our processing framerate:
        self.timer = jevois.Timer("dice", 50, jevois.LOG_DEBUG)

        # Instantiate a circular blob detector:
        params = cv2.SimpleBlobDetector_Params()
        params.filterByCircularity = True
        params.filterByArea = True
        params.minArea = 200.0

        self.detector = cv2.SimpleBlobDetector_create(params)

        # Create a morpho kernel (this was not in the original code?)
        self.kernel = np.ones((5,5), np.uint8)
        
    # ###################################################################################################
    ## Process function with no USB output
    #def processNoUSB(self, inframe):
    #    jevois.LFATAL("process no usb not implemented")

    # ###################################################################################################
    ## Process function with USB output
    def process(self, inframe, outframe):
        # Get the next camera image (may block until it is captured) and convert it to OpenCV BGR (for color output):
        img = inframe.getCvBGR()

        # Also convert it to grayscale for processing:
        grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        # Get image width, height:
        height, width = grayImage.shape

        # Start measuring image processing time (NOTE: does not account for input conversion time):
        self.timer.start()

        # filter noise
        grayImage = cv2.GaussianBlur(grayImage, (5, 5), 0, 0)

        # apply automatic threshold
        ret, grayImage = cv2.threshold(grayImage, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

        # background area
        grayImage = cv2.dilate(grayImage, self.kernel, iterations = 1) #self.morphBNo2)
        invBack2 = 255 - grayImage

        # blob detection
        keypoints = self.detector.detect(invBack2)
        nrOfBlobs = len(keypoints)

        # draw keypoints
        im_with_keypoints = cv2.drawKeypoints(img, keypoints, np.array([]), (255, 0, 0),
                                              cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
 
        # text only appears if at least 1 blob is detected
        if nrOfBlobs > 0:
            cv2.putText(im_with_keypoints, "total pips: {}".format(nrOfBlobs), (10, 25), cv2.FONT_HERSHEY_PLAIN,
                        2, (0, 255, 255, 255))

        # Write frames/s info from our timer (NOTE: does not account for output conversion time):
        fps = self.timer.stop()
        cv2.putText(im_with_keypoints, fps, (3, height - 6), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                    (255,255,255), 1, cv2.LINE_AA)
    
        # Convert our BGR image to video output format and send to host over USB:
        outframe.sendCvBGR(im_with_keypoints)
\endcode


其结果如下：

\image html dice3.png

\image html dice4.png

\image html dice5.png



请注意，此算法在 JeVois 上运行速度有点慢，大约每秒 8 帧。可以相应地调整视频映射。

我们很可能可以让它运行得更快，尤其是通过直接用 C++ 实现这个模块。我们会：

- 通过直接将输入 YUYV 帧复制到输出 YUYV 帧，并使用可以对 YUYV 图像进行操作的 JeVois 绘图函数（而不是 OpenCV 函数），消除从输入 YUYV 到 BGR 以及从输出 BGR 到 YUYV 的转换。
- 因此，仅对从 YUYV 到 GRAY 的图像进行处理。
- 并行处理灰度图像并将 YUYV 图像从相机复制到 USB。

包装模块
------------------

如果您使用的是 Linux 主机，并且一直在通过编辑主机上的 Python 文件来开发代码，然后运行 ​​`./rebuild-platform.sh --live` 将其安装到实时 JeVois 相机进行调试，那么您现在可以输入：

\verbatim
./rebuild-platform.sh
\endverbatim

它将安装到模块中的目录 \b jvpkg 中：

\verbatim
-- Installing: /lab/itti/pythondicecounter/jvpkg/modules/Tutorial/PythonDiceCounter
-- Installing: /lab/itti/pythondicecounter/jvpkg/modules/Tutorial/PythonDiceCounter/postinstall
-- Installing: /lab/itti/pythondicecounter/jvpkg/modules/Tutorial/PythonDiceCounter/PythonDiceCounter.py
\endverbatim

最后你输入：

\verbatim
cd pbuild
make jvpkg
\endverbatim

这将创建 <b>~/pythondicecounter/Tutorial_pythondicecounter.jvpkg</b>

您可以将该文件发送给您的朋友，并告诉他们将其复制到 microSD 上的 <b>JEVOIS:/packages/</b>。下次 JeVois 重新启动时，它将解压、安装、配置和删除该软件包，然后新模块即可使用。

*/

