/*! \page ProgrammerHello Hello JeVois

在本教程中，我们从头开始创建和编译一个新的 JeVois 机器视觉模块，并在主机（用于测试）和 JeVois 平台硬件上运行它。

我们将开发一个模块，将视频从摄像头传感器传输到主机，并在每个视频帧上添加一条消息 "Hello JeVois"。

准备工作 
-------------

- 请务必阅读 \ref Programmer 以了解基本概念。

- 请务必至少浏览一次 \ref ProgrammerSetup 。作为此操作的一部分，您将下载并编译此处所需的所有源代码和工具。

入门
---------------

<ul>

<li>我们按照 \ref ProgrammerSDK 中的说明开始使用我们的新模块。在这里，对于独立模块，我们将使用帮助脚本 <code>jevois-create-module</code>，它接受两个参数：vendor name（使用这个参数是为了确保如果模块由不同的人创建，则名称相同的模块可以存在）和 module name。因此，我们在这里输入：

\verbatim
cd
jevois-create-module Tutorial HelloJeVois
\endverbatim

这将创建一个目录 \b hellojevois 并在其中填充一些骨架文件：

\verbatim
hellojevois/
├── CMakeLists.txt
├── COPYING
├── INSTALL
├── README
├── rebuild-host.sh
├── rebuild-platform.sh
└── src
    └── Modules
        └── HelloJeVois
            ├── HelloJeVois.C
            ├── icon.png
            ├── postinstall
            └── screenshot1.png
\endverbatim

我们的模块的源文件是 <b>hellojevois/src/Modules/HelloJeVois.C</b>

有关此处创建的文件的更多信息，请参阅 \ref ProgrammerSDK 。</li>

<li>让我们确保主机编译环境正常工作。事实上，由 <code>jevois-create-module</code> 创建的骨架代码应该可以直接编译。要在主机上编译，我们从终端运行以下命令：

\verbatim
cd hellojevois
./rebuild-host.sh
\endverbatim

这将创建一个名为 \b hbuild 的目录，其中包含主机编译所需的所有中间构建文件，并产生

\verbatim
-- JeVois version 1.0
-- JEVOIS_SRC_ROOT: /lab/itti/jevois/software/jevois
-- JEVOIS_PLATFORM: OFF
-- JEVOIS_VENDOR: Tutorial
-- Install prefix for executables: /usr/local
-- Host path to jevois modules root: /jevois
-- The C compiler identification is GNU 5.2.1
-- The CXX compiler identification is GNU 5.2.1
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Adding compilation directives for module HelloJeVois base src/Modules
-- Configuring done
-- Generating done
-- Build files have been written to: /lab/itti/hellojevois/hbuild
Scanning dependencies of target modinfo_HelloJeVois
[ 50%] Generating ../src/Modules/HelloJeVois/modinfo.yaml, ../src/Modules/HelloJeVois/modinfo.html
[ 50%] Built target modinfo_HelloJeVois
Scanning dependencies of target HelloJeVois
[100%] Building CXX object CMakeFiles/HelloJeVois.dir/src/Modules/HelloJeVois/HelloJeVois.C.o
Linking CXX shared library HelloJeVois.so
[100%] Built target HelloJeVois
[sudo] password for itti: 
[ 50%] Built target modinfo_HelloJeVois
[100%] Built target HelloJeVois
Install the project...
-- Install configuration: ""
-- Installing: /jevois/modules/Tutorial/HelloJeVois
-- Installing: /jevois/modules/Tutorial/HelloJeVois/postinstall
-- Installing: /jevois/modules/Tutorial/HelloJeVois/modinfo.yaml
-- Installing: /jevois/modules/Tutorial/HelloJeVois/screenshot1.png
-- Installing: /jevois/modules/Tutorial/HelloJeVois/modinfo.html
-- Installing: /jevois/modules/Tutorial/HelloJeVois/icon.png
-- Installing: /jevois/modules/Tutorial/HelloJeVois/HelloJeVois.so
-- Removed runtime path from "/jevois/modules/Tutorial/HelloJeVois/HelloJeVois.so"
\endverbatim

该模块针对主机架构（此处为英特尔处理器）进行了编译，并安装到目标目录 <b>/jevois/modules/Tutorial/HelloJeVois/</b> 中，现在可以使用了。

</li>

<li>让我们尝试交叉编译 JeVois 智能相机硬件（ARM 处理器）的模块：
\verbatim
./rebuild-platform.sh
\endverbatim

这将创建一个名为 \b pbuild 的目录，其中包含平台编译所需的所有中间构建文件，并产生

\verbatim
-- JeVois version 1.0
-- JEVOIS_SRC_ROOT: /lab/itti/jevois/software/jevois
-- JEVOIS_PLATFORM: ON
-- JEVOIS_VENDOR: Tutorial
-- JEVOIS_MODULES_TO_BUILDROOT: OFF
-- Install prefix for executables: /lab/itti/jevois/software/jevois/../jevois-sdk/out/sun8iw5p1/linux/common/buildroot/target/usr
-- Host path to jevois modules root: /lab/itti/jevois/software/jevois/../jevois-sdk/out/sun8iw5p1/linux/common/buildroot/target/jevois
-- The C compiler identification is GNU 6.1.0
-- The CXX compiler identification is GNU 6.1.0
-- Check for working C compiler: /lab/itti/jevois/software/jevois/../jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-gcc
-- Check for working C compiler: /lab/itti/jevois/software/jevois/../jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /lab/itti/jevois/software/jevois/../jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-g++
-- Check for working CXX compiler: /lab/itti/jevois/software/jevois/../jevois-sdk/out/sun8iw5p1/linux/common/buildroot/host/usr/bin/arm-buildroot-linux-gnueabihf-g++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Adding compilation directives for module HelloJeVois base src/Modules
-- Configuring done
-- Generating done
-- Build files have been written to: /lab/itti/hellojevois/pbuild
Scanning dependencies of target modinfo_HelloJeVois
[ 50%] Built target modinfo_HelloJeVois
Scanning dependencies of target HelloJeVois
[100%] Building CXX object CMakeFiles/HelloJeVois.dir/src/Modules/HelloJeVois/HelloJeVois.C.o
Linking CXX shared library HelloJeVois.so
[100%] Built target HelloJeVois
[ 50%] Built target modinfo_HelloJeVois
[100%] Built target HelloJeVois
Install the project...
-- Install configuration: ""
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/postinstall
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/modinfo.yaml
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/screenshot1.png
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/modinfo.html
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/icon.png
-- Installing: /lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/HelloJeVois.so
-- Removed runtime path from "/lab/itti/hellojevois/jvpkg/modules/Tutorial/HelloJeVois/HelloJeVois.so"
\endverbatim

该模块已针对 JeVois 处理器进行了交叉编译，生成的文件已复制到 <b>~/hellojevois/jvpkg/</b>，它们已准备好打包成单个 JeVois 包文件，稍后可将其复制到 microSD 并在智能相机上运行。在此之前，让我们实际实现我们的模块，即在视频帧上写入 Hello JeVois 消息。</li>

</ul>

编写模块 
------------------

骨架代码已经为 HelloJeVois 类及其 \c process() 函数提供了初始实现。它实际上甚至已经写入了 "Hello JeVois"。因此，让我们看一下该代码，看起来我们不需要对本教程进行太多修改（如果有的话）：

\includelineno HelloJeVois.C

- 第 1 行：我们包含 jevois/Core/Module.H，从 JeVois 引入创建新模块所需的所有机制。

- 第 2 行：jevois/Image/RawImageOps.H 包含一些辅助函数，用于处理相机传感器捕获的原始图像，其中包括一个可以直接在这些图像中写入文本的函数。我们将使用该函数来写入文本。

- 第 6-37 行：我们使用 [doxygen](http://dogygen.org) 来记录 JeVois 框架中的代码。此外，我们还创建了自定义 doxygen 标签来记录视频映射和 JeVois 特有的其他功能。有关详细信息，请参阅 \ref ProgrammerSDK 。

- 第 38 行：我们声明我们的类并使其从 jevois::Module 派生。请注意，类名应与文件名以及模块文件所在的目录名（文件前的最后一级目录）完全匹配。

- 第 42 行：这里我们在构造时无需执行任何操作，因此我们只需继承 jevois::Module 的构造函数（如果您尚未看到，请参阅 \ref ModuleTutorial ，因为它包含许多指向 JeVois 中使用的概念的有用链接，例如，这里，继承 C++17 中的构造函数）。

- 第 48-73 行：此处的处理函数与 \ref ModuleTutorial 的 PassThrough 教程模块非常相似，但第 66 行有一个值得注意的附加内容：
  \verbatim
  jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 230, jevois::yuyv::White, jevois::rawimage::Font20x38);
  \endverbatim

- 第 77 行：请务必记住使用 JeVois 框架注册您的模块，以便 JeVois 引擎可以在运行时加载它。


为了好玩，让我们修改第 66 行并添加更多 \c writeText() 调用：

\code
  jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 230, jevois::yuyv::White, jevois::rawimage::Font20x38);
  jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 30, jevois::yuyv::LightGreen, jevois::rawimage::Font20x38);
  jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 400, jevois::yuyv::LightPink, jevois::rawimage::Font20x38);
\endcode

在主机上编译和测试 
-----------------------------

因为我们已经运行过 \c rebuild-host.sh 一次，并且从那时起我们没有添加任何新文件（这需要我们再次运行 CMake 来检测它们，例如再次运行 \c rebuild-host.sh ），我们可以使用 \ref ProgrammerSDK 中详述的部分编译命令（但请注意，由于我们这里只有一个文件需要编译，所以这并不能为我们节省太多时间）：

\verbatim
cd hbuild
make
sudo make install
\endverbatim

假设 JeVois 的所有内容都已编译，\c jevois-daemon 应该已经存在并准备就绪。但是，我们需要向 <b>/jevois/config/videomappings.cfg</b> 添加新的视频映射，以便让它知道何时以及如何使用我们的新模块。我们编辑 <b>/jevois/config/videomappings.cfg</b>（如果出现某些权限被拒绝错误，可能需要 \c sudo ），并添加一行：

\verbatim
YUYV 640 480 28.5 YUYV 640 480 28.5 Tutorial HelloJeVois
\endverbatim

或者，使用 \jvversion{1.3} 及更高版本，您只需在 Linux 终端中输入： 
\verbatim
sudo jevois-add-videomapping YUYV 640 480 28.5 YUYV 640 480 28.5 Tutorial HelloJeVois
\endverbatim


因此，当请求视频分辨率为 640x480 @ 28.5fps 时，JeVois 引擎现在将运行来自供应商 \b Tutorial 的模块 \b HelloJeVois 。有关更多信息，请参阅 \ref VideoMapping 。

现在我们需要一个普通的网络摄像头来测试这个，它应该支持 YUYV 640x480（帧速率不重要）。希望你有一个。当然，我们可以使用配置为 PassThrough 模式的 JeVois 摄像头来充当普通的哑摄像头，但有些人似乎对此感到困惑，因此它可能不适合这个入门级教程。如果您没有普通的 USB 网络摄像头，请直接跳到下一部分。

从运行开始

\verbatim
jevois-daemon
\endverbatim

它可能以另一种模式启动（如 DemoSaliency）。然后，在启动 \c jevois-daemon 的终端中，输入

\verbatim
listmappings
\endverbatim

并记下我们刚刚添加的、使用 HelloJevois 模块的映射编号。对于我们来说，它是映射 16：

\verbatim
...
   16 - OUT: YUYV 640x480 @ 28.5fps CAM: YUYV 640x480 @ 28.5fps MOD: Tutorial:HelloJeVois
...
\endverbatim

有关向 JeVois 发送命令以及有关 \c listmappings 命令的更多信息，请参阅 \ref UserCli 。

因此现在只需按 <code>CTRL-C</code> 即可停止 \c jevois-daemon ，然后使用映射 16（或任何您想要的数字）重新启动它：

\verbatim
jevois-daemon --videomapping=16
\endverbatim

你应该在终端中看到类似这样的内容：

\verbatim
INF Engine::Engine: Loaded 44 vision processing modes.
ERR Engine::onParamChange: Cannot set cpu max frequency -- IGNORED
ERR Engine::onParamChange: Cannot set cpu frequency governor mode -- IGNORED
INF Engine::onParamChange: Using [stdio] hardware (4-pin connector) serial port
INF Engine::onParamChange: No USB serial port used
INF Engine::postInit: Starting camera device /dev/video0
ERR Engine::postInit: Could not access VFE turbo parameter -- IGNORED
INF Camera::Camera: [12] V4L2 camera /dev/video0 card JeVois-A33 Smart Camera bus usb-0000:09:00.0-1.1.4
INF Engine::postInit: Using display for video output
init done
INF Engine::setFormatInternal: OUT: YUYV 640x480 @ 28.5fps CAM: YUYV 640x480 @ 28.5fps MOD: Tutorial:HelloJeVois
INF Camera::setFormat: Camera set video format to 640x480 YUYV
INF Engine::setFormatInternal: Instantiating dynamic loader for /jevois/modules/Tutorial/HelloJeVois/HelloJeVois.so
INF Engine::setFormatInternal: Module [HelloJeVois] loaded, initialized, and ready.
INF Camera::streamOn: 6 buffers of 614400 bytes allocated
INF READY JEVOIS 1.0
\endverbatim

窗口中显示如下内容：

\image html HelloJeVois1.png

稍微加点料 
-------------------

让我们在左上角添加一个小标题，并在底部显示 frames/s、CPU 频率和温度，就像在其他 JeVois 演示中一样。为此，我们将使用 jevois::Timer 类。

事实上，JeVois 框架提供了一个方便的 jevois::Timer 类来帮助你测量处理每个视频帧需要多少时间。它的工作原理如下：

- 在每一帧上，您都应该在计时器对象上发出 \c start() 来指示帧的开始（\c process() 函数的开始）。在从相机接收到帧后立即执行此操作，因此您不包括该帧的等待时间。

- 在进程结束时，发出 \c stop() 命令

计时器类将累计 100 帧的平均统计数据，并偶尔将其显示为信息消息。除了将消息写入控制台外，\c stop() 还会返回一个字符串，我们可以将其直接写入视频帧。计时器不会报告每一帧的统计数据，因为这可能会减慢我们的速度，尤其是通过串行端口发送这些报告时。

让我们首先包含 Timer 声明以便我们可以使用它：

\code
#include <jevois/Debug/Timer.H>
\endcode

然后我们将其添加到我们的 \c process() 函数中，同时在框架顶部添加消息。修改后的 \c process() 函数现在如下所示，带有 <code>////////////////////////////////////////////////////////////</code> 标记以帮助您查看修改（请注意，这里我们将计时器配置为每 60 帧报告一次，并在 \c LOG_DEBUG 级别输出文本报告，默认情况下不会打印到控制台）：

\code
    virtual void process(jevois::InputFrame && inframe, jevois::OutputFrame && outframe) override
    {
      static jevois::Timer timer("processing", 60, LOG_DEBUG); ////////////////////////////////////////////////////////
      
      // Wait for next available camera image:
      jevois::RawImage const inimg = inframe.get(true);

      timer.start(); ////////////////////////////////////////////////////////

      // We only support YUYV pixels in this example, any resolution:
      inimg.require("input", inimg.width, inimg.height, V4L2_PIX_FMT_YUYV);
      
      // Wait for an image from our gadget driver into which we will put our results:
      jevois::RawImage outimg = outframe.get();

      // Enforce that the input and output formats and image sizes match:
      outimg.require("output", inimg.width, inimg.height, inimg.fmt);
      
      // Just copy the pixel data over:
      memcpy(outimg.pixelsw<void>(), inimg.pixels<void>(), std::min(inimg.buf->length(), outimg.buf->length()));

      // Print a text message:
      jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 230, jevois::yuyv::White, jevois::rawimage::Font20x38);
      jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 30, jevois::yuyv::LightGreen, jevois::rawimage::Font20x38);
      jevois::rawimage::writeText(outimg, "Hello JeVois!", 100, 400, jevois::yuyv::LightPink, jevois::rawimage::Font20x38);

      // Let camera know we are done processing the input image:
      inframe.done(); // NOTE: optional here, inframe destructor would call it anyway

      ////////////////////////////////////////////////////////
      jevois::rawimage::writeText(outimg, "HelloJeVois Tutorial", 3, 3, jevois::yuyv::White);

      // Show processing fps:
      std::string const & fpscpu = timer.stop();
      jevois::rawimage::writeText(outimg, fpscpu, 3, outimg.height - 13, jevois::yuyv::White);
      ////////////////////////////////////////////////////////

      // Send the output image with our processing results to the host over USB:
      outframe.send(); // NOTE: optional here, outframe destructor would call it anyway
    }
\endcode


要重新编译并重新安装模块，我们只需输入：

\verbatim
cd hbuild
make && sudo make install
\endverbatim

我们可以再次启动 \c jevois-daemon ，现在的输出看起来像这样（将相机指向更暗的东西，这样我们就可以看到白色的小文本）：

\image html HelloJeVois2.png

这个帧速率很快（这是一台价值 15,000 美元的主机）。我们现在对我们的模块很满意。让我们在 JeVois 相机内运行它。

为 JeVois 硬件进行交叉编译 
-----------------------------------

由于我们已经在模块上运行了 \c rebuild-platform.sh ，并且从那时起我们没有添加任何新文件，因此我们可以对平台进行部分重新编译：

\verbatim
cd ~/hellojevois/pbuild
make && sudo make install && make jvpkg
\endverbatim

\note 如果您收到类似 <b>cc1plus: fatal error: jevois/Config/Config.H: No such file or directory</b> 的错误，您只需先在 \b jevois 目录中运行 \c rebuild-platform.sh 。

这将编译模块的所有文件，然后将其打包成 .jvpkg 包。您可以将该包放入 microSD 上的 <b>JEVOIS:/packages/</b>。下次启动时，JeVois 将解压、安装，然后删除该包。

为我们的模块定义视频映射 
---------------------------------------

在安装到相机之前，最后一件事是，我们将在模块中包含一个额外的视频映射，我们希望在安装模块时将其自动添加到 JeVois 相机的 \c videomappings.cfg 中。为此，我们编辑 <b>~/hellojevois/src/Module/HelloJeVois/postinstall</b>，如下所示：

\code{.py}
#!/bin/sh
# This script is executed once after the module is installed by JeVois if it was added to the jevois/packages/ directory
# of the microSD card as a .jvpkg file. The script is deleted from the microSD card after execution.
#
# The caller script will set the current directory to the location of this script before launching the script.

# Add our video mappings to the main mappings file:
jevois-add-videomapping YUYV 640 480 28.5 YUYV 640 480 28.5 Tutorial HelloJeVois

# Example of a simple message:
echo "HelloJeVois is now installed"
\endcode


当模块安装到智能相机上时，此映射将自动添加到现有映射列表中。这将通过 JeVois 自动运行我们模块目录中的 \b postinstall 脚本来实现。如果存在这样的脚本，它将在包解压后立即运行。它将在当前目录设置为模块目录的情况下运行。默认情况下，\c postinstall 包含简单的命令，只需将新模块的 \c videomappings.cfg 附加到 JeVois 的主 \c videomappings.cfg ，但如果您需要在安装包时运行其他自定义配置，则可以编辑此脚本。

使用 .jvpkg 包安装到 JeVois 硬件 
----------------------------------------------------

让我们创建一个包含我们模块的所有文件的包：

\verbatim
cd ~/hellojevois/pbuild
make jvpkg
\endverbatim

这将创建 <b>~/hellojevois/Tutorial_hellojevois.jvpkg</b>，其中包含将此模块安装到我们的智能相机上所需的一切。

我们将智能相机的 microSD 卡连接到主机，并将包文件复制到 microSD 卡上的 <b>JEVOIS:/packages/</b>。下次启动智能相机时，它将解压包，安装模块 .so 文件，运行 \c postinstall 脚本（将更新视频映射）等，然后我们就可以开始了。如下所示：

\verbatim
cp Tutorial_hellojevois.jvpkg /media/itti/JEVOIS/packages/
\endverbatim

（将上面的 \b itti 替换为您的用户名）。然后将 microSD 插入我们的 JeVois 智能相机并启动它。


\note 使用 \jvversion{1.1} 及更高版本，您不需要从 JeVois 中物理移除 microSD，而是可以在 JeVois 连接到主机并运行时将其导出为虚拟 USB 闪存驱动器：

- 通过向 JeVois 命令行界面发出命令 \c usbsd 将 microSD 导出为虚拟 USB 闪存驱动器（请参阅 \ref UserCli ）。确保 JeVois 没有流式传输视频。然后使用终端连接到它并发送 \c usbsd 命令，或者，简而言之，您可以在主机上键入：`echo usbsd | sudo tee /dev/ttyACM0`。
- JeVois 内部 microSD 的 JEVOIS 分区在您的主机上显示为新的 USB 闪存驱动器。它还应作为 /media/<em>username</em>/JEVOIS/ 安装

- 您现在可以使用 `cp Tutorial_hellojevois.jvpkg /media/<em>username</em>/JEVOIS/packages/` 将 jvpkg 复制到 microSD

- 弹出 USB 闪存驱动器，JeVois 将自动重新启动并解压并安装包。

使用 \jvversion{1.2} 及更高版本，您只需输入 `jevois-usbsd start` 即可开始导出 emicroSD，输入 `jevois-usbsd stop` 即可弹出它并重新启动 JeVois。

在主机上启动 \c guvcview 。请注意，JeVois 可能需要更多时间才能启动，因为它正在解压并安装我们的模块。这只是这次完成的操作，一旦安装完所有文件，软件包将从 microSD 中删除。

将 \c guvcview 设置为 YUYV 640x480，您将注意到新的 28.5fps 帧速率（在某些版本的 \c guvcview 中将显示为 57/2）。选择它，然后您会看到：

\image html HelloJeVois3.png

如果这里出现问题（将 .jvpkg 文件复制到 <b>JEVOIS:/packages/</b> 后 JeVois 智能相机无法启动，或者 \c guvcview 中未出现 640x480 @ 28.5fps 模式），请检查以下内容：

- 文件 \b Tutorial_hellojevois.jvpkg 应该从 <b>JEVOIS:/packages/</b> 中消失（成功解压并安装包后它会被删除）；

- 您应该有一个新的目录 <b>JEVOIS:/modules/Tutorial/HelloJeVois/</b>，其中包含文件 \b HelloJeVois.so （模块的可执行代码）；

- 您应该在<b>JEVOIS:/config/videomappings.cfg</b>的末尾看到新的 28.5fps 映射；

- 文件 <b>JEVOIS:/modules/Tutorial/HelloJeVois/postinstall</b> 应该被删除（它在 postinstall 脚本运行后被删除）。

- 为了调试解包和安装问题，我们建议将您的 JeVois 智能相机切换到详细启动（参见 \ref Debugging ）并使用 FTDI 电缆或类似设备连接到 JeVois 微串行端口以监视启动过程并检查 .jvpkg 解包和安装过程中是否有任何错误消息（如果需要，可以为 JeVois 专门设计的电缆 [此处](https://www.jevoisinc.com/collections/accessories/products/usb-to-micro-serial-adapter-cable-3-feet-1m-long) 提供）。

使用 jevois-sdk 的暂存区安装到 JeVois 硬件 
------------------------------------------------------------------

如果您想使用 jevois-sdk 提供的最新操作系统、核心文件等重新刷新整个 microSD，请使用此方法。

JeVois 的整个操作系统是在 jevois-sdk 下创建的，生成的文件被放置在两个暂存目录中：<b>/var/lib/jevois-build</b> 用于系统文件，<b>/var/lib/jevois-microsd</b> 用于将进入 JEVOIS 分区的文件。有关详细信息，请参阅 \ref ProgrammerOrganization 。然后可以将其安装到全新的 microSD 卡上。

要将新模块包含到暂存区，请运行以下命令：

\verbatim
cd ~/hellojevois
./rebuild-platform.sh
\endverbatim

这会将所有文件复制到暂存区。

如果您的模块中有一个 \b postinstall 脚本可以添加新的视频映射，那么下次 JeVois 重新启动时，这些脚本仍会附加到主 \b videomappings.cfg 中。

然后你就可以照常刷写一张新的 microSD 卡了（参见 \ref FlashingToSD ）：

\verbatim
sudo jevois-flash-card -y /dev/sdX
\endverbatim

（将上面的 \b sdX 替换为您的 microSD 设备）。


*/

