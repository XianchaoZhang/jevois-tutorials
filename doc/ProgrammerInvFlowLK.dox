/*! \page ProgrammerInvFlowLK 计算光流来检测移动物体或移动相机

本教程实现了一个简单的光流算法，该算法基于从一个视频帧到下一个视频帧跟踪兴趣点。这既可用于在摄像机静止时检测视频中的移动物体，也可用于检测摄像机本身何时移动。

本教程还旨在演示如何轻松地将其他 Python OpenCV 教程移植到 JeVois。

\image html flowlk0.jpg 电影序列中兴趣点追踪示例。图片来自 OpenCV 文档（见下方链接）。

方法
-------- 

- 我们从 https://docs.opencv.org/4.0.0-alpha/d7/d8b/tutorial_py_lucas_kanade.html 开始

- 我们将在该教程中开发的代码移植到 JeVois

- 我们将对其进行少许修改，以检测所有跟踪点何时超出视野范围，在这种情况下，我们将检测一组新的兴趣点并对其进行跟踪。

创建模块
-------------------

- 从 JeVois Inventor 的下拉菜单中选择<b>新建 Python 模块...</b>（或按 `CTRL-N`）。

- 填写如下所示的详细信息：
  
  \jvimg{flowlk1.png, 30%} 
- 允许 JeVois 重新启动，从 <b>Vision Module</b> 下拉菜单中选择您的新模块，然后切换到 Inventor 的 <b>Code</b> 选项卡。

分析原始代码 
---------------------------

我们首先阅读 https://docs.opencv.org/4.0.0-alpha/d7/d8b/tutorial_py_lucas_kanade.html 上的教程

以下是该教程的第一段代码：

\code{.py}
import numpy as np
import cv2 as cv
cap = cv.VideoCapture('slow.flv')
# ShiTomasi 角点检测的参数
feature_params = dict( maxCorners = 100,
                       qualityLevel = 0.3,
                       minDistance = 7,
                       blockSize = 7 )
# Parameters for lucas kanade optical flow
lk_params = dict( winSize  = (15,15),
                  maxLevel = 2,
                  criteria = (cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 0.03))
# Create some random colors
color = np.random.randint(0,255,(100,3))
# 取第一帧并在其中找到角点
ret, old_frame = cap.read()
old_gray = cv.cvtColor(old_frame, cv.COLOR_BGR2GRAY)
p0 = cv.goodFeaturesToTrack(old_gray, mask = None, **feature_params)
# 创建一个用于绘制的掩码图像
mask = np.zeros_like(old_frame)
while(1):
    ret,frame = cap.read()
    frame_gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    # calculate optical flow
    p1, st, err = cv.calcOpticalFlowPyrLK(old_gray, frame_gray, p0, None, **lk_params)
    # Select good points
    good_new = p1[st==1]
    good_old = p0[st==1]
    # draw the tracks
    for i,(new,old) in enumerate(zip(good_new,good_old)):
        a,b = new.ravel()
        c,d = old.ravel()
        mask = cv.line(mask, (a,b),(c,d), color[i].tolist(), 2)
        frame = cv.circle(frame,(a,b),5,color[i].tolist(),-1)
    img = cv.add(frame,mask)
    cv.imshow('frame',img)
    k = cv.waitKey(30) & 0xff
    if k == 27:
        break
    # 现在更新前一帧和前一个点
    old_gray = frame_gray.copy()
    p0 = good_new.reshape(-1,1,2)
cv.destroyAllWindows()
cap.release()
\endcode

要将代码移植到 JeVois，我们需要解决以下问题：

- 我们的 JeVois 模块是一个 Python 类，具有类成员函数，例如在每一帧上调用 `process()`。这意味着：
  + JeVois 引擎运行抓取图像的主循环，将它们发送到处理（我们的模块），并通过 USB 将结果发送到主机。因此，我们将删除与以下内容相关的任何代码：
    - 运行主循环，如原始代码中的 `while(1)`；
    - 抓取图像，如 `cap.read()`；我们将用传递给 `process()` 的内框上的 `get()` 替换它；
    - 以及显示或用户交互，如 `cv.imshow()`、`cv.waitKey()` 等；相反，我们将在 `process()` 的末尾运行 `send()` 以获取最终结果图像。
    - 有关更多详细信息，请参阅 \ref Concepts 和 \ref ModulePythonTutorial 
  + 我们将使用类成员变量（名称类似于 <b>self.var</b>），而不是全局变量（或在主循环之外创建的变量）。我们在模块的构造函数中初始化这些变量：成员函数 `__init__(self)`。

- 查看原始代码，此算法有两个阶段：
  + 程序启动后，抓取视频帧并使用 `goodFeaturesToTrack()` 检测一些兴趣点，这会找到一些看起来相当独特的点，我们希望这些点可以在下一个视频帧中再次看到，即使相机或物体可能移动了一点。
  + 然后，在每个后续帧上，使用 `calcOpticalFlowPyrLK()` 跟踪这些点。生成的点集（可能移动了一点）将替换旧的点集，以便可以在下一个视频帧上跟踪新的点集。

  JeVois 不允许在初始化期间抓取帧。我们唯一可以处理帧的时间是调用模块的 `process()` 函数时。因此，我们将根据成员变量 <b>self.old_gray</b> 是否存在来决定在 `process()` 中做什么（提取要跟踪的好特征，或跟踪它们）：
  + 在第一帧（第一次调用 `process()`）上，它不存在，然后我们找到要跟踪的好特征并创建 <b>self.old_gray</b>；

  + 在后续帧中，<b>self.old_gray</b> 存在，我们使用它作为提示来跟踪检测到的点。

- 一个小细节：在这个例子中，作者将 cv2 导入为 cv（即，他们对 OpenCV 函数使用前缀 `cv.`），而我们通常只导入 cv2（并使用前缀 `cv2.`）。

- 最后一个细节是，当所有跟踪点都从视野中消失时，变量 <b>p1</b> 将变为 `NoneType`。这在尝试对行 `good_new = p1[st==1]` 中的 \b p1 进行子索引时引发异常；因此，在我们的模块中，我们添加了一个测试 `if p1 is None:`，其中我们只是删除 <b>self.old_gray</b>，这将触发在下次调用 `process()` 时查找要跟踪的新好点。

编写 JeVois 代码 
-----------------------

\code{.py}
import libjevois as jevois
import cv2
import numpy as np

## 使用 Lucas-Kanade 的光流
#
# 在此处添加一些模块描述。
#
# @author Laurent Itti
# 
# @videomapping YUYV 320 240 23 YUYV 320 240 23 JeVois FlowLK
# @email itti@usc.edu
# @address 123 first street, Los Angeles CA 90012, USA
# @copyright Copyright (C) 2018 by Laurent Itti
# @mainurl http://jevois.org
# @supporturl http://jevois.org
# @otherurl http://jevois.org
# @license GPL v3
# @distribution Unrestricted
# @restrictions None
# @ingroup modules
class FlowLK:
    def __init__(self):
        # params for ShiTomasi corner detection
        self.feature_params = dict( maxCorners = 100,
                       qualityLevel = 0.3,
                       minDistance = 7,
                       blockSize = 7 )
        
        # Parameters for lucas kanade optical flow
        self.lk_params = dict( winSize  = (15,15),
                       maxLevel = 2,
                       criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03))
        
        # Create some random colors
        self.color = np.random.randint(0,255,(100,3))
        
        # Create a timer for frame rate:
        self.timer = jevois.Timer('FlowLK', 50, jevois.LOG_DEBUG)
        
    def process(self, inframe, outframe):
        # Grab a frame from camera sensor:
        frame = inframe.getCvBGR()
        self.timer.start()
        
        # If first frame, detect good interest points to track:
        if not hasattr(self, 'old_gray'):
            self.old_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            self.p0 = cv2.goodFeaturesToTrack(self.old_gray, mask = None, **self.feature_params)
            self.mask = np.zeros_like(frame)
            
        else: # if not first frame, track the interest points from previous frame to current:
            frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            
            # calculate optical flow
            p1, st, err = cv2.calcOpticalFlowPyrLK(self.old_gray, frame_gray, self.p0, None, **self.lk_params)
            
            # Select good points, if any, otherwise restart:
            if p1 is None:
                frame = cv2.add(frame, self.mask)
                del self.old_gray
            else:
                good_new = p1[st==1]
                good_old = self.p0[st==1]
            
                # draw the tracks
                for i,(new, old) in enumerate(zip(good_new, good_old)):
                    a,b = new.ravel()
                    c,d = old.ravel()
                    self.mask = cv2.line(self.mask, (a,b),(c,d), self.color[i].tolist(), 2)
                    frame = cv2.circle(frame, (a,b), 5, self.color[i].tolist(), -1)
                frame = cv2.add(frame, self.mask)
            
                # Now update the previous frame and previous points
                self.old_gray = frame_gray.copy()
                self.p0 = good_new.reshape(-1, 1, 2)
        
        # Send results to host computer over USB:
        fps = self.timer.stop()
        cv2.putText(frame, fps, (3,frame.shape[0]-7), cv2.FONT_HERSHEY_SIMPLEX,
                  0.4, (255,255,255), 1, cv2.LINE_AA)
        outframe.sendCv(frame)

\endcode

现在我们开始！

\jvimg{flowlk2.png, 70%}

实际上相当快，80 到 140 帧/秒，取决于跟踪的点数。

\jvimg{flowlk3.png, 70%}


进一步 
-------------

- 尝试此处研究的 OpenCV 教程第二部分中的密集光流计算。

- 尝试将其他 OpenCV 教程移植到 JeVois。

*/

